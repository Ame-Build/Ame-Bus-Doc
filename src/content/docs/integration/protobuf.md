---
title: Protobuf
---

Shizuku provides Protocol Buffers serialization support through the `protobuf` feature flag. This integration uses `prost` for serialization and deserialization.

## Installation

1. Add the `protobuf` feature to your Shizuku dependency in `Cargo.toml`:

```toml
// Cargo.toml
[dependencies]
shizuku = { version = "0.0.2-alpha.2", features = ["protobuf"] }
```

2. Add `prost-build` to your build dependencies:

```toml
// Cargo.toml
[build-dependencies]
prost-build = "0.13"
```

3. Create a `build.rs` file in your project root to compile `.proto` files:

```rust
// /build.rs
fn main() {
    prost_build::compile_protos(&["src/proto/user.proto"], &["src/proto"])
        .unwrap();
}
```

4. Create your `.proto` files in the specified directory (e.g., `src/proto/user.proto`):

```protobuf
// src/proto/user.proto
syntax = "proto3";

package user;

message User {
    string id = 1;
    string name = 2;
    string email = 3;
}
```

:::note
Make sure to create the proto directory and include it in your version control system.
:::

## Usage

The Protobuf integration provides two macros for implementing serialization traits:
- `protobuf_ser`: Implements `ByteSerialize` for Protobuf serialization
- `protobuf_des`: Implements `ByteDeserialize` for Protobuf deserialization

### Example

```rust
// src/lib.rs
use prost::Message;
use shizuku::{protobuf_ser, protobuf_des};

// Include the generated protobuf code
include!(concat!(env!("OUT_DIR"), "/user.rs"));

// Implement serialization and deserialization for the User type
protobuf_ser!(User);
protobuf_des!(User);
```

This will automatically implement:
- `ByteSerialize` for converting the struct to Protobuf bytes
- `ByteDeserialize` for parsing Protobuf bytes back into the struct

:::note
The types generated by prost already implement `prost::Message`, which is required for using these macros.
:::

### Using in Services

The Protobuf serialization works seamlessly with NATS services:

```rust
// Include the generated protobuf code
include!(concat!(env!("OUT_DIR"), "/user.rs"));

// Use the generated types from the proto file
use user::{CreateUserRequest, CreateUserResponse};

// Implement serialization and deserialization
protobuf_ser!(CreateUserRequest);
protobuf_des!(CreateUserResponse);

impl NatsRpcCallTrait<CreateUserResponse> for CreateUserRequest {
    fn subject() -> (NatsSubjectPath, PhantomData<CreateUserResponse>) {
        (subject_path!["user", "create"], PhantomData)
    }
}
```

### Using with JetStream

You can use Protobuf serialization for JetStream events and consumers:

```rust
use shizuku::{protobuf_ser, protobuf_des, DynamicSubjectMessage, JetStreamMessageSendTrait};
use shizuku::jetstream::FinalJetStreamProcessor;

// Include the generated protobuf code
include!(concat!(env!("OUT_DIR"), "/order.rs"));

// Use the generated types
use order::OrderCreatedEvent;

// Implement serialization
protobuf_ser!(OrderCreatedEvent);

// Implement dynamic subject for the event
impl DynamicSubjectMessage for OrderCreatedEvent {
    fn subject(&self) -> NatsSubjectPath {
        subject_path!["order", "created", &self.order_id]
    }
}

// The trait is automatically implemented
impl JetStreamMessageSendTrait for OrderCreatedEvent {}

// Define a consumer that processes Protobuf messages
// Use the generated OrderData type from the proto file
use order::OrderData;

// Implement deserialization
protobuf_des!(OrderData);

struct OrderProcessor;

impl Processor<Message, Result<(), Error>> for OrderProcessor {
    async fn process(&self, msg: Message) -> Result<(), Error> {
        // Parse Protobuf message
        let order = OrderData::parse_from_bytes(msg.payload)?;

        // Process the order
        println!("Processing order: {}", order.order_id);
        Ok(())
    }
}
```

:::note
### Legacy Derive Macro Approach (Not Recommended)

Shizuku previously provided derive macros that can be used instead of the function-like macros, but this approach is no longer recommended:
- `ProtoSer`: Implements `ByteSerialize` for Protobuf serialization
- `ProtoDes`: Implements `ByteDeserialize` for Protobuf deserialization

Instead, use the `protobuf_ser` and `protobuf_des` function-like macros as shown in the examples above, which provide better flexibility when working with types defined in external crates.
:::

