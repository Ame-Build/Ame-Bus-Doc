---
title: Protobuf
---

import { Steps, Code } from '@astrojs/starlight/components';

Shizuku provides Protocol Buffers serialization support through the `protobuf` feature flag. This integration uses `prost` for serialization and deserialization.

## Installation

<Steps>

1. Add the `protobuf` feature to your Shizuku dependency in `Cargo.toml`:

    ```toml ins="\"protobuf\""
        // Cargo.toml
        [dependencies]
        shizuku = { version = "0.0.2-alpha.2", features = ["protobuf"] }
    ```

2. Add `prost-build` to your build dependencies:

    ```toml
    // Cargo.toml
    [build-dependencies]
    prost-build = "0.13"
    ```

3. Create a `build.rs` file in your project root to compile `.proto` files:

    ```rust
    // /build.rs
    fn main() {
        prost_build::compile_protos(&["src/proto/user.proto"], &["src/proto"])
            .unwrap();
    }
    ```

4. Create a module file to include the generated code (e.g., `src/user.rs`):

    ```rust
    // src/user.rs

    // Include the generated protobuf code
    pub mod proto {
        include!(concat!(env!("OUT_DIR"), "/user.rs"));
    }

    // Re-export the types you want to use directly
    pub use proto::User;
    pub use proto::CreateUserRequest;
    pub use proto::CreateUserResponse;

    // Implement serialization and deserialization for the types
    use shizuku::{protobuf_ser, protobuf_des};

    protobuf_ser!(User);
    protobuf_des!(User);
    protobuf_ser!(CreateUserRequest);
    protobuf_des!(CreateUserResponse);
    ```

5. Create your `.proto` files in the specified directory (e.g., `src/proto/user.proto`):

    ```protobuf
    // src/proto/user.proto
    syntax = "proto3";

    package user;

    message User {
        string id = 1;
        string name = 2;
        string email = 3;
    }
    ```

    :::note
    Make sure to create the proto directory and include it in your version control system.
    :::

</Steps>

## Usage

The Protobuf integration provides two macros for implementing serialization traits:
- `protobuf_ser`: Implements `ByteSerialize` for Protobuf serialization
- `protobuf_des`: Implements `ByteDeserialize` for Protobuf deserialization

:::note
The types generated by prost already implement `prost::Message`, which is required for using these macros.
:::

### Using in Services

The Protobuf serialization works seamlessly with NATS services:

```rust
// src/user.rs

use shizuku::{protobuf_ser, protobuf_des, NatsRpcCallTrait};
include!(concat!(env!("OUT_DIR"), "/user.rs"));

impl NatsRpcCallTrait<CreateUserResponse> for CreateUserRequest {
    fn subject() -> (NatsSubjectPath, PhantomData<CreateUserResponse>) {
        (subject_path!["user", "create"], PhantomData)
    }
}

protobuf_ser!(CreateUserRequest);
protobuf_des!(CreateUserResponse);
```

### Using with JetStream

You can use Protobuf serialization for JetStream events and consumers:

```rust
// src/order.rs

use shizuku::{protobuf_ser, protobuf_des, DynamicSubjectMessage, JetStreamMessageSendTrait};
include!(concat!(env!("OUT_DIR"), "/order.rs"));

// Implement serialization
protobuf_ser!(OrderCreatedEvent);
protobuf_des!(OrderData);
```

```rust
// src/app.rs

use shizuku::{DynamicSubjectMessage, JetStreamMessageSendTrait};
use shizuku::jetstream::FinalJetStreamProcessor;
use crate::order::{OrderCreatedEvent, OrderData};

// Implement dynamic subject for the event
impl DynamicSubjectMessage for OrderCreatedEvent {
    fn subject(&self) -> NatsSubjectPath {
        subject_path!["order", "created", &self.order_id]
    }
}

// The trait is automatically implemented
impl JetStreamMessageSendTrait for OrderCreatedEvent {}

// Define a consumer that processes Protobuf messages

struct OrderProcessor;

impl Processor<Message, Result<(), Error>> for OrderProcessor {
    async fn process(&self, msg: Message) -> Result<(), Error> {
        // Parse Protobuf message
        let order = OrderData::parse_from_bytes(msg.payload)?;

        // Process the order
        println!("Processing order: {}", order.order_id);
        Ok(())
    }
}
```

:::note
### Legacy Derive Macro Approach (Not Recommended)

Shizuku previously provided derive macros that can be used instead of the function-like macros, but this approach is no longer recommended:
- `ProtoSer`: Implements `ByteSerialize` for Protobuf serialization
- `ProtoDes`: Implements `ByteDeserialize` for Protobuf deserialization

Instead, use the `protobuf_ser` and `protobuf_des` function-like macros as shown in the examples above, which provide better flexibility when working with types defined in external crates.
:::

